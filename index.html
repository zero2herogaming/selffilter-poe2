<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PoE2 Filter Builder (No Waystones) - v1.0.0</title>
  <style>
    /* Overall Layout */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
      background: #f0f0f0;
      color: #333;
    }
    #left-panel, #right-panel {
      padding: 1rem;
      overflow-y: auto;
    }
    #left-panel {
      width: 45%;
      background: #fff;
      border-right: 2px solid #ccc;
    }
    #right-panel {
      width: 55%;
      background: #f8f8f8;
    }

    /* HEADINGS */
    h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1.2rem;
      color: #222;
    }
    .version {
      font-size: 0.85rem;
      color: #777;
      margin-bottom: 1rem;
    }

    /* RULE CARDS */
    .rule-card {
      background: #fafafa;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 1rem;
      padding: 0.5rem 0.75rem;
    }
    .rule-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .rule-header h3 {
      margin: 0;
      font-size: 1rem;
      color: #444;
    }
    .rule-header button {
      padding: 0.3rem 0.6rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      background: #eee;
      cursor: pointer;
      border-radius: 4px;
    }
    .rule-header button:hover {
      background: #ddd;
    }
    .rule-body {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .rule-body label {
      display: inline-block;
      margin-right: 0.5rem;
      margin-bottom: 0.3rem;
      font-size: 0.9rem;
    }
    .rule-body select,
    .rule-body input[type="number"],
    .rule-body input[type="color"] {
      margin-right: 0.3rem;
      font-size: 0.9rem;
    }

    /* ADD RULE BUTTON */
    #addRuleButton {
      display: inline-block;
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      background: #4caf50;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
    }
    #addRuleButton:hover {
      background: #45a045;
    }

    /* RIGHT PANEL PREVIEW */
    #filterPreview {
      white-space: pre;
      background: #eee;
      padding: 0.75rem;
      height: calc(100% - 3.5rem);
      overflow-y: auto;
      font-family: monospace;
      border: 1px solid #ccc;
    }

    /* DOWNLOAD */
    #downloadBtn {
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.5rem 1rem;
      background: #2196f3;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
    }
    #downloadBtn:hover {
      background: #1e88e5;
    }
    #download-link {
      display: none;
    }
  </style>
</head>
<body>
  <!-- LEFT: RULES & ADD RULE BUTTON -->
  <div id="left-panel">
    <h2>PoE2 Filter Rules (No Waystones)</h2>
    <div class="version">Version v1.0.0</div>
    <button id="addRuleButton">+ Add Rule</button>
    <div id="rulesContainer"></div>
  </div>

  <!-- RIGHT: PREVIEW & DOWNLOAD -->
  <div id="right-panel">
    <h2>Live Filter Preview</h2>
    <div id="filterPreview"></div>
    <button id="downloadBtn">Download Filter</button>
    <a id="download-link" href="#" download="my-filter.filter">Download Link</a>
  </div>

  <script>
    /***************************************************************
     * 1. Define ALL categories & items (NO WAYSTONES) - v1.0.0
     ***************************************************************/
    const CATEGORIES = [
      {
        id: "gems",
        name: "Gems (No Rarity / No Sockets)",
        isGemsCategory: true,
        items: [
          { name: "Uncut Spirit Gem", usesItemLevel: true,  isStackable: false },
          { name: "Uncut Support Gem", usesItemLevel: true,  isStackable: false },
          { name: "Uncut Skill Gem",   usesItemLevel: true,  isStackable: false },
          { name: "Soul Core",        usesItemLevel: false, isStackable: false },
          { name: "Timeless",         usesItemLevel: false, isStackable: false },
          { name: "Relic",            usesItemLevel: false, isStackable: false }
        ]
      },
      {
        id: "onehand",
        name: "One-Handed Weapons",
        isGemsCategory: false,
        items: [
          { name: "Claws",             usesItemLevel:true, isStackable:false },
          { name: "Daggers",           usesItemLevel:true, isStackable:false },
          { name: "Wands",             usesItemLevel:true, isStackable:false },
          { name: "One Hand Swords",   usesItemLevel:true, isStackable:false },
          { name: "One Hand Axes",     usesItemLevel:true, isStackable:false },
          { name: "One Hand Maces",    usesItemLevel:true, isStackable:false },
          { name: "Sceptres",          usesItemLevel:true, isStackable:false },
          { name: "Spears",            usesItemLevel:true, isStackable:false },
          { name: "Flails",            usesItemLevel:true, isStackable:false },
          { name: "Attuned Wand",      usesItemLevel:true, isStackable:false },
          { name: "Siphoning Wand",    usesItemLevel:true, isStackable:false },
          { name: "Spiked Club",       usesItemLevel:true, isStackable:false }
        ]
      },
      {
        id: "twohand",
        name: "Two-Handed Weapons",
        isGemsCategory: false,
        items: [
          { name: "Bows",             usesItemLevel:true, isStackable:false },
          { name: "Staves",           usesItemLevel:true, isStackable:false },
          { name: "Quarterstaves",    usesItemLevel:true, isStackable:false },
          { name: "Crossbows",        usesItemLevel:true, isStackable:false },
          { name: "Crude Bow",        usesItemLevel:true, isStackable:false },
          { name: "Long Quarterstaff",usesItemLevel:true, isStackable:false }
        ]
      },
      {
        id: "offhand",
        name: "Off-hand Items",
        isGemsCategory: false,
        items: [
          { name: "Quivers",            usesItemLevel:true,  isStackable:false },
          { name: "Shields",            usesItemLevel:true,  isStackable:false },
          { name: "Foci",               usesItemLevel:true,  isStackable:false },
          { name: "Stone Tower Shield", usesItemLevel:false, isStackable:true }
        ]
      },
      {
        id: "armour",
        name: "Armour",
        isGemsCategory: false,
        items: [
          { name: "Gloves",            usesItemLevel:true,  isStackable:false },
          { name: "Boots",             usesItemLevel:true,  isStackable:false },
          { name: "Body Armours",      usesItemLevel:true,  isStackable:false },
          { name: "Helmets",           usesItemLevel:true,  isStackable:false },
          { name: "Armoured Cap",      usesItemLevel:false, isStackable:true },
          { name: "Furtive Wraps",     usesItemLevel:false, isStackable:true },
          { name: "Smuggler Coat",     usesItemLevel:false, isStackable:true },
          { name: "Wrapped Greathelm", usesItemLevel:false, isStackable:true }
        ]
      },
      {
        id: "jewellery",
        name: "Jewellery",
        isGemsCategory: false,
        items: [
          { name: "Rings",         usesItemLevel:true,  isStackable:false },
          { name: "Amulets",       usesItemLevel:true,  isStackable:false },
          { name: "Belts",         usesItemLevel:true,  isStackable:false },
          { name: "Heavy Belt",    usesItemLevel:false, isStackable:true },
          { name: "Ornate Belt",   usesItemLevel:false, isStackable:true },
          { name: "Utility Belt",  usesItemLevel:false, isStackable:true },
          { name: "Grand Regalia", usesItemLevel:false, isStackable:true },
          { name: "Breach Ring",   usesItemLevel:false, isStackable:true },
          { name: "Emerald",       usesItemLevel:false, isStackable:true },
          { name: "Ruby",          usesItemLevel:false, isStackable:true },
          { name: "Sapphire",      usesItemLevel:false, isStackable:true }
        ]
      },
      {
        id: "flasks",
        name: "Flasks",
        isGemsCategory: false,
        items: [
          { name: "Flask",               usesItemLevel:true,  isStackable:true },
          { name: "Life Flasks",         usesItemLevel:false, isStackable:false },
          { name: "Mana Flasks",         usesItemLevel:false, isStackable:false },
          { name: "Ultimate Life Flask", usesItemLevel:false, isStackable:true },
          { name: "Ultimate Mana Flask", usesItemLevel:false, isStackable:true }
        ]
      },
      {
        id: "currency",
        name: "Currency",
        isGemsCategory: false,
        items: [
          { name: "Mirror",                usesItemLevel:false,isStackable:true },
          { name: "Divine",                usesItemLevel:false,isStackable:true },
          { name: "Perfect Jeweller's Orb",usesItemLevel:false,isStackable:true },
          { name: "Greater Jeweller's Orb",usesItemLevel:false,isStackable:true },
          { name: "Distilled Isolation",   usesItemLevel:false,isStackable:true },
          { name: "Distilled Suffering",   usesItemLevel:false,isStackable:true },
          { name: "Distilled Fear",        usesItemLevel:false,isStackable:true },
          { name: "Distilled Despair",     usesItemLevel:false,isStackable:true },
          { name: "Distilled Disgust",     usesItemLevel:false,isStackable:true },
          { name: "Catalyst",              usesItemLevel:false,isStackable:true },
          { name: "Essence of",            usesItemLevel:false,isStackable:true },
          { name: "Chaos Orb",             usesItemLevel:false,isStackable:true },
          { name: "Exotic",                usesItemLevel:false,isStackable:true },
          { name: "Exalted Orb",           usesItemLevel:false,isStackable:true },
          { name: "Vaal Orb",              usesItemLevel:false,isStackable:true },
          { name: "Gemcutter's Prism",     usesItemLevel:false,isStackable:true },
          { name: "Gold",                  usesItemLevel:false,isStackable:true },
          { name: "Neural Catalyst",       usesItemLevel:false,isStackable:true },
          { name: "Adaptive Catalyst",     usesItemLevel:false,isStackable:true },
          { name: " Artifact",             usesItemLevel:false,isStackable:true },
          { name: "Arcanist's Etcher",     usesItemLevel:false,isStackable:true },
          { name: "Blacksmith's Whetstone",usesItemLevel:false,isStackable:true },
          { name: "Artificer's Orb",       usesItemLevel:false,isStackable:true },
          { name: "Regal Orb",             usesItemLevel:false,isStackable:true },
          { name: "Shard",                 usesItemLevel:false,isStackable:true },
          { name: "Aug",                   usesItemLevel:false,isStackable:true },
          { name: "Orb of Transmutation",  usesItemLevel:false,isStackable:true }
        ]
      },
      {
        id: "jewels",
        name: "Jewels",
        isGemsCategory: false,
        items: [
          { name: "Jewel",             usesItemLevel:true,  isStackable:false },
          { name: " Rune",             usesItemLevel:false, isStackable:false },
          { name: " Charm",            usesItemLevel:false, isStackable:false },
          { name: "Timeless Jewel",    usesItemLevel:false, isStackable:false },
          { name: "Time-Lost Diamond", usesItemLevel:false, isStackable:true }
        ]
      },
      {
        id: "fragments",
        name: "Fragments",
        isGemsCategory: false,
        items: [
          { name: "Transmutation Shard",        usesItemLevel:false,isStackable:true },
          { name: "Chance Shard",               usesItemLevel:false,isStackable:true },
          { name: "Regal Shard",                usesItemLevel:false,isStackable:true },
          { name: "Artificer's Shard",          usesItemLevel:false,isStackable:true },
          { name: "Scroll of Wisdom",           usesItemLevel:false,isStackable:true },
          { name: "Breach Splinter",            usesItemLevel:false,isStackable:true },
          { name: "Breachstone",                usesItemLevel:false,isStackable:true },
          { name: "Simulacrum Splinter",        usesItemLevel:false,isStackable:true },
          { name: "Simulacrum",                 usesItemLevel:false,isStackable:true },
          { name: "An Audience with the King",  usesItemLevel:false,isStackable:true },
          { name: "Cowardly Fate",              usesItemLevel:false,isStackable:true },
          { name: "Deadly Fate",                usesItemLevel:false,isStackable:true },
          { name: "Victorious Fate",            usesItemLevel:false,isStackable:true },
          { name: "Ancient Crisis Fragment",    usesItemLevel:false,isStackable:true },
          { name: "Faded Crisis Fragment",      usesItemLevel:false,isStackable:true },
          { name: "Weathered Crisis Fragment",  usesItemLevel:false,isStackable:true }
        ]
      },
      {
        id: "runes",
        name: "Runes",
        isGemsCategory: false,
        items: [
          { name: "Desert Rune",     usesItemLevel:false,isStackable:false },
          { name: "Glacial Rune",    usesItemLevel:false,isStackable:false },
          { name: "Storm Rune",      usesItemLevel:false,isStackable:false },
          { name: "Iron Rune",       usesItemLevel:false,isStackable:false },
          { name: "Body Rune",       usesItemLevel:false,isStackable:false },
          { name: "Mind Rune",       usesItemLevel:false,isStackable:false },
          { name: "Rebirth Rune",    usesItemLevel:false,isStackable:false },
          { name: "Inspiration Rune",usesItemLevel:false,isStackable:false },
          { name: "Stone Rune",      usesItemLevel:false,isStackable:false },
          { name: "Vision Rune",     usesItemLevel:false,isStackable:false }
        ]
      },
      {
        id: "essences",
        name: "Essences",
        isGemsCategory: false,
        items: [
          { name: "Essence of the Body",            usesItemLevel:false,isStackable:true },
          { name: "Essence of the Mind",            usesItemLevel:false,isStackable:true },
          { name: "Essence of Enhancement",         usesItemLevel:false,isStackable:true },
          { name: "Essence of Torment",             usesItemLevel:false,isStackable:true },
          { name: "Essence of Flames",              usesItemLevel:false,isStackable:true },
          { name: "Essence of Ice",                 usesItemLevel:false,isStackable:true },
          { name: "Essence of Electricity",         usesItemLevel:false,isStackable:true },
          { name: "Essence of Ruin",                usesItemLevel:false,isStackable:true },
          { name: "Essence of Battle",              usesItemLevel:false,isStackable:true },
          { name: "Essence of Sorcery",             usesItemLevel:false,isStackable:true },
          { name: "Essence of Haste",               usesItemLevel:false,isStackable:true },
          { name: "Essence of the Infinite",        usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of the Body",    usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of the Mind",    usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Enhancement", usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Torment",     usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Flames",      usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Ice",         usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Electricity", usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Ruin",        usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Battle",      usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Sorcery",     usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of Haste",       usesItemLevel:false,isStackable:true },
          { name: "Greater Essence of the Infinite",usesItemLevel:false,isStackable:true }
        ]
      },
      {
        id: "soulcores",
        name: "Soul Cores",
        isGemsCategory: false,
        items: [
          { name: "Soul Core of Tacati",    usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Opiloti",   usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Jiquani",   usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Zalatl",    usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Citaqualotl", usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Puhuarte",  usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Tzamoto",   usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Xopec",     usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Azcapa",    usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Topotante",usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Quipolatl",usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Ticaba",    usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Atmohua",   usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Cholotl",   usesItemLevel:false,isStackable:false },
          { name: "Soul Core of Zantipi",   usesItemLevel:false,isStackable:false }
        ]
      },
      {
        id: "breachcatalysts",
        name: "Breach Catalysts",
        isGemsCategory: false,
        items: [
          { name: "Flesh Catalyst",false,true },
          { name: "Neural Catalyst",false,true },
          { name: "Carapace Catalyst",false,true },
          { name: "Uul-Netol's Catalyst",false,true },
          { name: "Xoph's Catalyst",false,true },
          { name: "Tul's Catalyst",false,true },
          { name: "Esh's Catalyst",false,true },
          { name: "Chayula's Catalyst",false,true },
          { name: "Reaver Catalyst",false,true },
          { name: "Sibilant Catalyst",false,true },
          { name: "Skittering Catalyst",false,true },
          { name: "Adaptive Catalyst",false,true }
        ]
      },
      {
        id: "expedition",
        name: "Expedition Coinage & Artifacts",
        isGemsCategory: false,
        items: [
          { name: "Exotic Coinage",false,true },
          { name: "Broken Circle Artifact",false,true },
          { name: "Black Scythe Artifact",false,true },
          { name: "Order Artifact",false,true },
          { name: "Sun Artifact",false,true }
        ]
      },
      {
        id: "ritualomens",
        name: "Ritual Omens",
        isGemsCategory: false,
        items: [
          { name: "Omen of Refreshment",false,true },
          { name: "Omen of Resurgence",false,true },
          { name: "Omen of Amelioration",false,true },
          { name: "Omen of Whittling",false,true },
          { name: "Omen of Sinistral Erasure",false,true },
          { name: "Omen of Dextral Erasure",false,true },
          { name: "Omen of Sinistral Alchemy",false,true },
          { name: "Omen of Dextral Alchemy",false,true },
          { name: "Omen of Sinistral Coronation",false,true },
          { name: "Omen of Dextral Coronation",false,true },
          { name: "Omen of Corruption",false,true },
          { name: "Omen of Greater Exaltation",false,true },
          { name: "Omen of Sinistral Exaltation",false,true },
          { name: "Omen of Dextral Exaltation",false,true },
          { name: "Omen of Greater Annulment",false,true },
          { name: "Omen of Sinistral Annulment",false,true },
          { name: "Omen of Dextral Annulment",false,true }
        ]
      },
      {
        id: "deliriumdistillations",
        name: "Delirium Distillations",
        isGemsCategory: false,
        items: [
          { name: "Distilled Ire",false,true },
          { name: "Distilled Guilt",false,true },
          { name: "Distilled Greed",false,true },
          { name: "Distilled Paranoia",false,true },
          { name: "Distilled Envy",false,true },
          { name: "Distilled Disgust",false,true },
          { name: "Distilled Despair",false,true },
          { name: "Distilled Fear",false,true },
          { name: "Distilled Suffering",false,true },
          { name: "Distilled Isolation",false,true }
        ]
      }
    ];

    /***************************************************************
     * 2. The 'rules' array holds all user-defined rules
     ***************************************************************/
    let rules = [];

    /***************************************************************
     * 3. "Add Rule" => create a new rule card
     ***************************************************************/
    window.addEventListener("DOMContentLoaded", () => {
      document.getElementById("addRuleButton").addEventListener("click", createRuleCard);
      document.getElementById("downloadBtn").addEventListener("click", downloadFilter);
      renderPreview(); // initially empty
    });

    function createRuleCard() {
      // We'll create a blank rule object with default values
      const defaultCat = CATEGORIES[0];
      const newRule = {
        categoryId: defaultCat.id,
        itemName:   defaultCat.items[0].name,
        showHide:   "Show",
        rarities:   [],
        socketsVal: 0,
        qualityVal: 0,
        itemLevelVal: 0,
        stackVal:   0,
        areaOp:     "",
        areaVal:    0,
        textC:      "#ffffff",
        borderC:    "#ffffff",
        bgC:        "#000000",
        fontC:      35,
        alertSound: "",
        alertDur:   300,
        mmSize:     "",
        mmColor:    "",
        mmShape:    ""
      };
      rules.push(newRule);
      renderRules();
      renderPreview();
    }

    /***************************************************************
     * 4. RENDER ALL RULE CARDS
     ***************************************************************/
    function renderRules() {
      const container = document.getElementById("rulesContainer");
      container.innerHTML = "";
      rules.forEach((rule, index) => {
        const card = document.createElement("div");
        card.classList.add("rule-card");

        // Header
        const header = document.createElement("div");
        header.classList.add("rule-header");
        const title = document.createElement("h3");
        title.textContent = `Rule ${index + 1}`;
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", () => {
          rules.splice(index, 1);
          renderRules();
          renderPreview();
        });
        header.appendChild(title);
        header.appendChild(removeBtn);
        card.appendChild(header);

        // Body
        const body = document.createElement("div");
        body.classList.add("rule-body");
        
        // 1) Category
        const catLabel = document.createElement("label");
        catLabel.textContent = "Category: ";
        const catSelect = document.createElement("select");
        CATEGORIES.forEach(cat => {
          const opt = document.createElement("option");
          opt.value = cat.id;
          opt.textContent = cat.name;
          if (cat.id === rule.categoryId) opt.selected = true;
          catSelect.appendChild(opt);
        });
        catLabel.appendChild(catSelect);
        body.appendChild(catLabel);

        // 2) Item
        const itemLabel = document.createElement("label");
        itemLabel.textContent = " Item: ";
        const itemSelect = document.createElement("select");
        itemLabel.appendChild(itemSelect);
        body.appendChild(itemLabel);

        function fillItemSelect(catId, ruleObj) {
          itemSelect.innerHTML = "";
          const catObj = CATEGORIES.find(c => c.id === catId);
          if (!catObj) return;
          catObj.items.forEach(it => {
            const opt = document.createElement("option");
            opt.value = it.name;
            opt.textContent = it.name;
            if (it.name === ruleObj.itemName) opt.selected = true;
            itemSelect.appendChild(opt);
          });
        }
        fillItemSelect(rule.categoryId, rule);

        // 3) Show/Hide
        const showHideLabel = document.createElement("label");
        showHideLabel.textContent = " Action: ";
        const showHideSel = document.createElement("select");
        ["Show", "Hide"].forEach(val => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val;
          if (val === rule.showHide) opt.selected = true;
          showHideSel.appendChild(opt);
        });
        showHideLabel.appendChild(showHideSel);
        body.appendChild(showHideLabel);

        // 4) Rarities => hidden if isGemsCategory
        const catObjRef = () => CATEGORIES.find(c => c.id === rule.categoryId);
        const isGems = () => catObjRef()?.isGemsCategory === true;

        const rarityWrap = document.createElement("div");
        rarityWrap.style.display = isGems() ? "none" : "inline-block";
        rarityWrap.innerHTML = `
          <label><input type="checkbox" data-rarity="Normal"/> Normal</label>
          <label><input type="checkbox" data-rarity="Magic" /> Magic</label>
          <label><input type="checkbox" data-rarity="Rare"  /> Rare</label>
          <label><input type="checkbox" data-rarity="Unique"/> Unique</label>
        `;
        body.appendChild(rarityWrap);

        // 5) Sockets => hidden if gems
        const socketsLabel = document.createElement("label");
        socketsLabel.style.display = isGems() ? "none" : "inline-block";
        socketsLabel.innerHTML = ` Sockets >: <input type="number" style="width:50px;" value="${rule.socketsVal}"/>`;
        body.appendChild(socketsLabel);

        // 6) Quality
        const qualityLabel = document.createElement("label");
        qualityLabel.innerHTML = ` Quality >: <input type="number" style="width:50px;" value="${rule.qualityVal}"/>`;
        body.appendChild(qualityLabel);

        // 7) itemLevel
        const itemLevelLabel = document.createElement("label");
        itemLevelLabel.innerHTML = ` ItemLevel =: <input type="number" style="width:50px;" value="${rule.itemLevelVal}"/>`;
        body.appendChild(itemLevelLabel);

        // 8) stackSize
        const stackLabel = document.createElement("label");
        stackLabel.innerHTML = ` StackSize >=: <input type="number" style="width:50px;" value="${rule.stackVal}"/>`;
        body.appendChild(stackLabel);

        // 9) areaLevel
        const areaWrap = document.createElement("label");
        areaWrap.innerHTML = ` AreaLevel:
          <select>
            <option value="">None</option>
            <option value=">=" ${rule.areaOp === ">=" ? "selected" : ""}>>=</option>
            <option value="<=" ${rule.areaOp === "<=" ? "selected" : ""}>&lt;=</option>
            <option value="="  ${rule.areaOp === "="  ? "selected" : ""}>=</option>
          </select>
          <input type="number" style="width:50px;" value="${rule.areaVal}"/>
        `;
        body.appendChild(areaWrap);

        // 10) Colors + Font
        const textColorLabel = document.createElement("label");
        textColorLabel.innerHTML = ` TextColor: <input type="color" value="${rule.textC}"/>`;
        body.appendChild(textColorLabel);

        const borderColorLabel = document.createElement("label");
        borderColorLabel.innerHTML = ` BorderColor: <input type="color" value="${rule.borderC}"/>`;
        body.appendChild(borderColorLabel);

        const bgColorLabel = document.createElement("label");
        bgColorLabel.innerHTML = ` Background: <input type="color" value="${rule.bgC}"/>`;
        body.appendChild(bgColorLabel);

        const fontSizeLabel = document.createElement("label");
        fontSizeLabel.innerHTML = ` FontSize: <input type="number" style="width:45px;" value="${rule.fontC}" min="12" max="60"/>`;
        body.appendChild(fontSizeLabel);

        // 11) Alert Sound
        const alertWrap = document.createElement("label");
        alertWrap.innerHTML = ` AlertSound:
          <select>
            <option value="">None</option>
            <option value="1"  ${rule.alertSound === "1"  ? "selected" : ""}>1</option>
            <option value="2"  ${rule.alertSound === "2"  ? "selected" : ""}>2</option>
            <option value="3"  ${rule.alertSound === "3"  ? "selected" : ""}>3</option>
            <option value="4"  ${rule.alertSound === "4"  ? "selected" : ""}>4</option>
            <option value="6"  ${rule.alertSound === "6"  ? "selected" : ""}>6</option>
            <option value="10" ${rule.alertSound === "10" ? "selected" : ""}>10</option>
          </select>
          <input type="number" style="width:55px;" value="${rule.alertDur}" min="50" max="1000"/>
        `;
        body.appendChild(alertWrap);

        // 12) MinimapIcon
        const mmWrap = document.createElement("div");
        mmWrap.innerHTML = `
          <label>Minimap Icon:
            Size:
            <select>
              <option value="">None</option>
              <option value="0" ${rule.mmSize==="0" ? "selected" : ""}>0</option>
              <option value="1" ${rule.mmSize==="1" ? "selected" : ""}>1</option>
              <option value="2" ${rule.mmSize==="2" ? "selected" : ""}>2</option>
              <option value="3" ${rule.mmSize==="3" ? "selected" : ""}>3</option>
            </select>
            Color:
            <select>
              <option value="">None</option>
              <option value="White"  ${rule.mmColor==="White" ? "selected" : ""}>White</option>
              <option value="Red"    ${rule.mmColor==="Red"   ? "selected" : ""}>Red</option>
              <option value="Blue"   ${rule.mmColor==="Blue"  ? "selected" : ""}>Blue</option>
              <option value="Green"  ${rule.mmColor==="Green" ? "selected" : ""}>Green</option>
              <option value="Brown"  ${rule.mmColor==="Brown" ? "selected" : ""}>Brown</option>
              <option value="Yellow" ${rule.mmColor==="Yellow"? "selected" : ""}>Yellow</option>
              <option value="Cyan"   ${rule.mmColor==="Cyan"  ? "selected" : ""}>Cyan</option>
              <option value="Grey"   ${rule.mmColor==="Grey"  ? "selected" : ""}>Grey</option>
            </select>
            Shape:
            <select>
              <option value="">None</option>
              <option value="Square"   ${rule.mmShape==="Square"   ? "selected":""}>Square</option>
              <option value="Circle"   ${rule.mmShape==="Circle"   ? "selected":""}>Circle</option>
              <option value="Star"     ${rule.mmShape==="Star"     ? "selected":""}>Star</option>
              <option value="Diamond"  ${rule.mmShape==="Diamond"  ? "selected":""}>Diamond</option>
              <option value="Triangle" ${rule.mmShape==="Triangle" ? "selected":""}>Triangle</option>
              <option value="Kite"     ${rule.mmShape==="Kite"     ? "selected":""}>Kite</option>
            </select>
          </label>
        `;
        body.appendChild(mmWrap);

        card.appendChild(body);
        container.appendChild(card);

        /*** EVENT LISTENERS ***/

        // Category
        catSelect.addEventListener("change", () => {
          rule.categoryId = catSelect.value;
          const newCatObj = CATEGORIES.find(c => c.id === rule.categoryId);
          if (newCatObj?.items?.length) {
            rule.itemName = newCatObj.items[0].name;
          }
          fillItemSelect(rule.categoryId, rule);
          updateRaritySocketsVisibility(rarityWrap, socketsLabel, rule.categoryId);
          updateItemLevelStackVisibility(itemLevelLabel, stackLabel, rule);
          renderPreview();
        });

        // Item
        itemSelect.addEventListener("change", () => {
          rule.itemName = itemSelect.value;
          updateItemLevelStackVisibility(itemLevelLabel, stackLabel, rule);
          renderPreview();
        });

        // Show/Hide
        showHideSel.addEventListener("change", () => {
          rule.showHide = showHideSel.value;
          renderPreview();
        });

        // Rarity checkboxes
        const cbs = rarityWrap.querySelectorAll('input[type="checkbox"]');
        cbs.forEach(cb => {
          const rar = cb.getAttribute("data-rarity");
          cb.checked = rule.rarities.includes(rar);
          cb.addEventListener("change", () => {
            if (cb.checked) {
              if (!rule.rarities.includes(rar)) rule.rarities.push(rar);
            } else {
              rule.rarities = rule.rarities.filter(rr => rr !== rar);
            }
            renderPreview();
          });
        });

        // Sockets
        const socketsInput = socketsLabel.querySelector('input[type="number"]');
        socketsInput.addEventListener("change", () => {
          rule.socketsVal = parseInt(socketsInput.value || "0", 10);
          renderPreview();
        });

        // Quality
        const qualityInput = qualityLabel.querySelector('input[type="number"]');
        qualityInput.addEventListener("change", () => {
          rule.qualityVal = parseInt(qualityInput.value || "0", 10);
          renderPreview();
        });

        // ItemLevel
        const lvlInput = itemLevelLabel.querySelector('input[type="number"]');
        lvlInput.addEventListener("change", () => {
          rule.itemLevelVal = parseInt(lvlInput.value || "0", 10);
          renderPreview();
        });

        // StackSize
        const stInput = stackLabel.querySelector('input[type="number"]');
        stInput.addEventListener("change", () => {
          rule.stackVal = parseInt(stInput.value || "0", 10);
          renderPreview();
        });

        // AreaLevel
        const areaSel = areaWrap.querySelector('select');
        const areaNum = areaWrap.querySelector('input[type="number"]');
        areaSel.addEventListener("change", () => {
          rule.areaOp = areaSel.value;
          renderPreview();
        });
        areaNum.addEventListener("change", () => {
          rule.areaVal = parseInt(areaNum.value || "0", 10);
          renderPreview();
        });

        // Colors
        const textCInput = textColorLabel.querySelector('input[type="color"]');
        textCInput.addEventListener("change", () => {
          rule.textC = textCInput.value;
          renderPreview();
        });
        const borderCInput = borderColorLabel.querySelector('input[type="color"]');
        borderCInput.addEventListener("change", () => {
          rule.borderC = borderCInput.value;
          renderPreview();
        });
        const bgCInput = bgColorLabel.querySelector('input[type="color"]');
        bgCInput.addEventListener("change", () => {
          rule.bgC = bgCInput.value;
          renderPreview();
        });

        // FontSize
        const fontCInput = fontSizeLabel.querySelector('input[type="number"]');
        fontCInput.addEventListener("change", () => {
          rule.fontC = parseInt(fontCInput.value || "35", 10);
          renderPreview();
        });

        // AlertSound
        const sel2 = alertWrap.querySelector('select');
        const dur2 = alertWrap.querySelector('input[type="number"]');
        sel2.addEventListener("change", () => {
          rule.alertSound = sel2.value;
          renderPreview();
        });
        dur2.addEventListener("change", () => {
          rule.alertDur = parseInt(dur2.value || "300", 10);
          renderPreview();
        });

        // Minimap
        const mmSelects = mmWrap.querySelectorAll("select");
        mmSelects[0].addEventListener("change", () => {
          rule.mmSize = mmSelects[0].value;
          renderPreview();
        });
        mmSelects[1].addEventListener("change", () => {
          rule.mmColor = mmSelects[1].value;
          renderPreview();
        });
        mmSelects[2].addEventListener("change", () => {
          rule.mmShape = mmSelects[2].value;
          renderPreview();
        });

        // Initialize UI
        updateRaritySocketsVisibility(rarityWrap, socketsLabel, rule.categoryId);
        updateItemLevelStackVisibility(itemLevelLabel, stackLabel, rule);
      });
    }

    function updateRaritySocketsVisibility(rarityWrap, socketsLabel, catId) {
      const cat = CATEGORIES.find(c => c.id === catId);
      if (!cat) return;
      const isGems = cat.isGemsCategory === true;
      rarityWrap.style.display = isGems ? "none" : "inline-block";
      socketsLabel.style.display = isGems ? "none" : "inline-block";
    }

    function updateItemLevelStackVisibility(itemLevelLabel, stackLabel, ruleObj) {
      const cat = CATEGORIES.find(c => c.id === ruleObj.categoryId);
      if (!cat) return;
      const itemData = cat.items.find(i => i.name === ruleObj.itemName);
      if (!itemData) return;
      itemLevelLabel.style.display = itemData.usesItemLevel ? "inline-block" : "none";
      stackLabel.style.display = itemData.isStackable ? "inline-block" : "none";
    }

    /***************************************************************
     * 5. RENDER PREVIEW
     ***************************************************************/
    function renderPreview() {
      const preview = document.getElementById("filterPreview");
      preview.textContent = generateFullFilter();
    }

    function generateFullFilter() {
      let content = "";
      rules.forEach(r => {
        let block = r.showHide + "\n";

        // Rarities
        if (r.rarities && r.rarities.length > 0) {
          block += "  Rarity " + r.rarities.join(" ") + "\n";
        }
        // Sockets
        if (r.socketsVal > 0) {
          block += `  Sockets > ${r.socketsVal}\n`;
        }
        // Quality
        if (r.qualityVal > 0) {
          block += `  Quality > ${r.qualityVal}\n`;
        }
        // ItemLevel
        if (r.itemLevelVal > 0) {
          block += `  ItemLevel = ${r.itemLevelVal}\n`;
        }
        // StackSize
        if (r.stackVal > 0) {
          block += `  StackSize >= ${r.stackVal}\n`;
        }
        // AreaLevel
        if (r.areaOp && r.areaVal > 0) {
          block += `  AreaLevel ${r.areaOp} ${r.areaVal}\n`;
        }
        // Class or BaseType
        const cat = CATEGORIES.find(c => c.id === r.categoryId);
        const itemData = cat?.items.find(i => i.name === r.itemName);
        if (itemData && itemData.isStackable) {
          block += `  BaseType "${r.itemName}"\n`;
        } else {
          block += `  Class "${r.itemName}"\n`;
        }

        // Colors
        block += `  SetTextColor ${hexToRGB(r.textC)}\n`;
        block += `  SetBorderColor ${hexToRGB(r.borderC)}\n`;
        if (r.bgC.toLowerCase() !== "#ffffff") {
          block += `  SetBackgroundColor ${hexToRGB(r.bgC)}\n`;
        }
        block += `  SetFontSize ${r.fontC}\n`;

        // Alert Sound
        if (r.alertSound) {
          block += `  PlayAlertSound ${r.alertSound} ${r.alertDur}\n`;
        }
        // Minimap
        if (r.mmSize && r.mmColor && r.mmShape) {
          block += `  MinimapIcon ${r.mmSize} ${r.mmColor} ${r.mmShape}\n`;
        }
        block += "\n";
        content += block;
      });
      return content.trim();
    }

    /***************************************************************
     * 6. DOWNLOAD FILTER
     ***************************************************************/
    function downloadFilter() {
      const filterText = generateFullFilter();
      const blob = new Blob([filterText], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.getElementById("download-link");
      link.href = url;
      link.click();
    }

    /***************************************************************
     * Extra Utils
     ***************************************************************/
    function hexToRGB(hex) {
      const bigint = parseInt(hex.replace("#", ""), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `${r} ${g} ${b} 255`;
    }
  </script>
</body>
</html>
